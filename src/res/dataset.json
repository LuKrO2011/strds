{
  "repositories": [
    {
      "name": "mlvtools",
      "url": "https://github.com/peopledoc/mlvtools",
      "pypi_tag": "2.1.1",
      "git_commit_hash": "2a797303b2b0e988f8063fc1d418f65c821efa97",
      "modules": [
        {
          "name": "setup",
          "file_path": "setup.py",
          "functions": [
            {
              "name": "extract_scripts",
              "line_number": 14,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "root_dir",
                  "line_number": 14,
                  "col_offset": 21,
                  "type": "str"
                }
              ],
              "return_type": "List[str]",
              "body": "def extract_scripts(root_dir: str) -> List[str]:\n    return glob.glob(join(root_dir, '*'))",
              "signature": "extract_scripts(root_dir: str) -> List[str]",
              "full_signature": "extract_scripts(root_dir: str) -> List[str]",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "gen_dvc",
          "file_path": "mlvtools/gen_dvc.py",
          "functions": [
            {
              "name": "get_dvc_template_data",
              "line_number": 20,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "docstring_info",
                  "line_number": 20,
                  "col_offset": 27,
                  "type": "DocstringInfo"
                },
                {
                  "name": "working_directory",
                  "line_number": 20,
                  "col_offset": 58,
                  "type": "str"
                },
                {
                  "name": "python_cmd_path",
                  "line_number": 21,
                  "col_offset": 27,
                  "type": "str"
                },
                {
                  "name": "meta_file_variable_name",
                  "line_number": 21,
                  "col_offset": 49,
                  "type": "str"
                },
                {
                  "name": "meta_file_root_dir_path",
                  "line_number": 22,
                  "col_offset": 27,
                  "type": "str"
                },
                {
                  "name": "extra_variables",
                  "line_number": 22,
                  "col_offset": 57,
                  "type": "dict"
                }
              ],
              "return_type": null,
              "body": "def get_dvc_template_data(docstring_info: DocstringInfo, working_directory: str,\n                          python_cmd_path: str, meta_file_variable_name: str,\n                          meta_file_root_dir_path: str, extra_variables: dict = None):\n    \"\"\"\n        Format data from docstring for dvc bash command template\n    \"\"\"\n    logging.info('Build data for DVC command generation using template')\n    dvc_params = get_dvc_params(docstring_info.docstring)\n    variables = [] if not extra_variables else [f'{name}=\"{value}\"' for name, value in extra_variables.items()]\n    meta_file_name = dvc_params.meta_file_name or to_dvc_meta_filename(python_cmd_path)\n    meta_file_name = join(meta_file_root_dir_path, meta_file_name)\n\n    info = {\n        'variables': variables,\n        'meta_file_name_var_assign': f'{meta_file_variable_name}=\"{meta_file_name}\"',\n        'meta_file_name_var': meta_file_variable_name,\n        'whole_command': None,\n        'python_script': python_cmd_path,\n        'working_directory': working_directory,\n        'dvc_inputs': [],\n        'dvc_outputs': [],\n        'dvc_outputs_persist': [],\n        'python_params': ''\n    }\n\n    if dvc_params.dvc_cmd:\n        logging.info('DVC mode: whole command provided')\n        info['whole_command'] = dvc_params.dvc_cmd.cmd.replace('\\n', ' \\\\\\n')\n        logging.debug(f'Custom command {info[\"whole_command\"]}')\n        return info\n\n    logging.info('DVC mode: generate command from parameters')\n    python_params = []\n\n    def handle_params(dvc_docstring_params: List[DocstringDvc], label: str):\n        for dvc_param in dvc_docstring_params:\n            if dvc_param.related_param:\n                variable_name = to_bash_variable(dvc_param.related_param)\n                py_cmd_param = to_cmd_param(dvc_param.related_param)\n                info['variables'].append(f'{variable_name}=\"{dvc_param.file_path}\"')\n                python_params.append(f'--{py_cmd_param} ${variable_name}')\n                info[label].append(f'${variable_name}')\n            else:\n                info[label].append(dvc_param.file_path)\n\n    for extra_param in dvc_params.dvc_extra:\n        python_params.append(extra_param.extra)\n\n    handle_params(dvc_params.dvc_in, 'dvc_inputs')\n    handle_params(dvc_params.dvc_out, 'dvc_outputs')\n    handle_params(dvc_params.dvc_out_persist, 'dvc_outputs_persist')\n    info['python_params'] = ' '.join(python_params)\n    logging.debug(f'Template info: {info}')\n    return info",
              "signature": "get_dvc_template_data(docstring_info: DocstringInfo, working_directory: str, python_cmd_path: str, meta_file_variable_name: str, meta_file_root_dir_path: str, extra_variables: dict)",
              "full_signature": "get_dvc_template_data(docstring_info: DocstringInfo, working_directory: str, python_cmd_path: str, meta_file_variable_name: str, meta_file_root_dir_path: str, extra_variables: dict)",
              "annotations": ""
            },
            {
              "name": "gen_dvc_command",
              "line_number": 76,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "input_path",
                  "line_number": 76,
                  "col_offset": 21,
                  "type": "str"
                },
                {
                  "name": "dvc_output_path",
                  "line_number": 76,
                  "col_offset": 38,
                  "type": "str"
                },
                {
                  "name": "conf",
                  "line_number": 76,
                  "col_offset": 60,
                  "type": "MlVToolConf"
                },
                {
                  "name": "docstring_conf",
                  "line_number": 76,
                  "col_offset": 79,
                  "type": "dict"
                }
              ],
              "return_type": null,
              "body": "def gen_dvc_command(input_path: str, dvc_output_path: str, conf: MlVToolConf, docstring_conf: dict = None):\n    logging.info(f'Generate DVC command \"{dvc_output_path}\" from \"{input_path}\"')\n    logging.debug(f'Global configuration {conf}')\n    logging.debug(f'Docstring configuration {docstring_conf}')\n\n    docstring_info = extract_docstring_from_file(input_path, docstring_conf)\n\n    python_cmd_rel_path = relpath(input_path, conf.top_directory)\n    extra_var = {conf.dvc_var_python_cmd_path: python_cmd_rel_path,\n                 conf.dvc_var_python_cmd_name: basename(python_cmd_rel_path)}\n    info = get_dvc_template_data(docstring_info,\n                                 conf.top_directory,\n                                 python_cmd_rel_path,\n                                 conf.dvc_var_meta_filename,\n                                 conf.path.dvc_metadata_root_dir if conf.path else '',\n                                 extra_var)\n\n    templates_path = join(CURRENT_DIR, 'templates', DVC_CMD_TEMPLATE_NAME)\n    write_template(dvc_output_path, templates_path, info=info)\n\n    logging.log(logging.WARNING + 1, f'DVC bash command successfully generated in {dvc_output_path}')",
              "signature": "gen_dvc_command(input_path: str, dvc_output_path: str, conf: MlVToolConf, docstring_conf: dict)",
              "full_signature": "gen_dvc_command(input_path: str, dvc_output_path: str, conf: MlVToolConf, docstring_conf: dict)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "cmd",
          "file_path": "mlvtools/cmd.py",
          "functions": [],
          "classes": [
            {
              "name": "CommandHelper",
              "methods": [
                {
                  "name": "get_conf",
                  "line_number": 37,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "self",
                      "line_number": 37,
                      "col_offset": 18,
                      "type": null
                    },
                    {
                      "name": "working_dir_arg",
                      "line_number": 37,
                      "col_offset": 24,
                      "type": "str"
                    },
                    {
                      "name": "input_file_arg",
                      "line_number": 37,
                      "col_offset": 46,
                      "type": "str"
                    },
                    {
                      "name": "conf_path_arg",
                      "line_number": 37,
                      "col_offset": 67,
                      "type": "str"
                    }
                  ],
                  "return_type": "MlVToolConf",
                  "body": "def get_conf(self, working_dir_arg: str, input_file_arg: str, conf_path_arg: str) -> MlVToolConf:\n        conf_path = conf_path_arg or get_conf_file_default_path(working_dir_arg)\n        return load_conf_or_default(conf_path, working_dir_arg)",
                  "signature": "CommandHelper.get_conf(self, working_dir_arg: str, input_file_arg: str, conf_path_arg: str) -> MlVToolConf",
                  "full_signature": "CommandHelper.get_conf(self, working_dir_arg: str, input_file_arg: str, conf_path_arg: str) -> MlVToolConf",
                  "annotations": "",
                  "is_constructor": false
                }
              ],
              "superclasses": [],
              "fields": []
            }
          ]
        },
        {
          "name": "ipynb_to_python",
          "file_path": "mlvtools/ipynb_to_python.py",
          "functions": [
            {
              "name": "get_config",
              "line_number": 28,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "template_path",
                  "line_number": 28,
                  "col_offset": 16,
                  "type": "str"
                }
              ],
              "return_type": "Dict[str, Dict[str, str]]",
              "body": "def get_config(template_path: str) -> Dict[str, Dict[str, str]]:\n    return {'TemplateExporter': {'template_file': template_path},\n            'NbConvertApp': {'export_format': 'python'}}",
              "signature": "get_config(template_path: str) -> Dict[str, Dict[str, str]]",
              "full_signature": "get_config(template_path: str) -> Dict[str, Dict[str, str]]",
              "annotations": ""
            },
            {
              "name": "export_to_script",
              "line_number": 33,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "input_notebook_path",
                  "line_number": 33,
                  "col_offset": 22,
                  "type": "str"
                },
                {
                  "name": "output_path",
                  "line_number": 33,
                  "col_offset": 48,
                  "type": "str"
                },
                {
                  "name": "conf",
                  "line_number": 33,
                  "col_offset": 66,
                  "type": "MlVToolConf"
                }
              ],
              "return_type": null,
              "body": "def export_to_script(input_notebook_path: str, output_path: str, conf: MlVToolConf):\n    \"\"\"\n        Export a notebook to a parameterize Python 3 script\n        using Jinja templates\n    \"\"\"\n    logging.info(f'Generate Python script {output_path} from Jupyter Notebook {input_notebook_path}')\n    logging.debug(f'Global Configuration: {conf}')\n    logging.debug(f'Template path {TEMPLATE_PATH}')\n\n    script_content = get_converted_script(input_notebook_path, conf)\n\n    if not script_content:\n        logging.warning('Empty notebook provided. Nothing to do.')\n        return\n    write_python_script(script_content, output_path)\n    logging.log(logging.WARNING + 1, f'Python script successfully generated in {abspath(output_path)}')",
              "signature": "export_to_script(input_notebook_path: str, output_path: str, conf: MlVToolConf)",
              "full_signature": "export_to_script(input_notebook_path: str, output_path: str, conf: MlVToolConf)",
              "annotations": ""
            },
            {
              "name": "get_converted_script",
              "line_number": 51,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "input_notebook_path",
                  "line_number": 51,
                  "col_offset": 26,
                  "type": "str"
                },
                {
                  "name": "conf",
                  "line_number": 51,
                  "col_offset": 52,
                  "type": "MlVToolConf"
                }
              ],
              "return_type": "str",
              "body": "def get_converted_script(input_notebook_path: str, conf: MlVToolConf) -> str:\n    \"\"\"\n        Extract notebook python content using nbconvert\n    \"\"\"\n    exporter = PythonExporter(get_config(TEMPLATE_PATH))\n    exporter.register_filter(name='filter_trailing_cells',\n                             jinja_filter=filter_trailing_cells)\n    exporter.register_filter(name='get_formatted_cells',\n                             jinja_filter=get_formatted_cells)\n    exporter.register_filter(name='get_data_from_docstring',\n                             jinja_filter=get_data_from_docstring)\n    exporter.register_filter(name='sanitize_method_name',\n                             jinja_filter=to_method_name)\n    resources = {'ignore_keys': conf.ignore_keys}\n    logging.debug(f'Template info {resources}')\n    try:\n        script_content, _ = exporter.from_filename(input_notebook_path, resources=resources)\n    except Exception as e:\n        raise MlVToolException(e) from e\n    return script_content",
              "signature": "get_converted_script(input_notebook_path: str, conf: MlVToolConf) -> str",
              "full_signature": "get_converted_script(input_notebook_path: str, conf: MlVToolConf) -> str",
              "annotations": ""
            },
            {
              "name": "get_arguments_as_param",
              "line_number": 92,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "docstring_data",
                  "line_number": 92,
                  "col_offset": 28,
                  "type": "Docstring"
                }
              ],
              "return_type": "str",
              "body": "def get_arguments_as_param(docstring_data: Docstring) -> str:\n    \"\"\"\n        Get formatted parameter for python method call\n    \"\"\"\n    return ', '.join([f'args.{arg.arg_name}' for arg in docstring_data.params])",
              "signature": "get_arguments_as_param(docstring_data: Docstring) -> str",
              "full_signature": "get_arguments_as_param(docstring_data: Docstring) -> str",
              "annotations": ""
            },
            {
              "name": "get_param_as_python_method_format",
              "line_number": 99,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "docstring_data",
                  "line_number": 99,
                  "col_offset": 39,
                  "type": "Docstring"
                }
              ],
              "return_type": "str",
              "body": "def get_param_as_python_method_format(docstring_data: Docstring) -> str:\n    \"\"\"\n        Extract parameters from a docstring then format them\n    \"\"\"\n    return ', '.join(f'{p.arg_name}' for p in docstring_data.params)",
              "signature": "get_param_as_python_method_format(docstring_data: Docstring) -> str",
              "full_signature": "get_param_as_python_method_format(docstring_data: Docstring) -> str",
              "annotations": ""
            },
            {
              "name": "get_docstring_data",
              "line_number": 106,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "cell_content",
                  "line_number": 106,
                  "col_offset": 24,
                  "type": "str"
                }
              ],
              "return_type": "Tuple[Docstring, str]",
              "body": "def get_docstring_data(cell_content: str) -> Tuple[Docstring, str]:\n    \"\"\"\n        Extract docstring and formatted parameters from a cell content\n    \"\"\"\n    docstring_str = extract_docstring(cell_content)\n    if docstring_str:\n        return parse_docstring(docstring_str), f'\"\"\"\\n{docstring_str}\\n\"\"\"'\n    logging.warning(\"Docstring not found.\")\n    return Docstring(), ''",
              "signature": "get_docstring_data(cell_content: str) -> Tuple[Docstring, str]",
              "full_signature": "get_docstring_data(cell_content: str) -> Tuple[Docstring, str]",
              "annotations": ""
            },
            {
              "name": "is_no_effect",
              "line_number": 140,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "content",
                  "line_number": 140,
                  "col_offset": 18,
                  "type": "str"
                },
                {
                  "name": "resource",
                  "line_number": 140,
                  "col_offset": 32,
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "bool",
              "body": "def is_no_effect(content: str, resource: Dict[str, Any]) -> bool:\n    \"\"\"\n        Return true if the cell is a 'no effect cell'\n        'no effect cell' =  a 'code cell' with one of the configurable\n        'ignore_keys' as comment\n    \"\"\"\n    logging.debug('Look for no effect cells')\n    for keyword in resource.get('ignore_keys', [DEFAULT_IGNORE_KEY]):\n        if keyword in content:\n            return True\n    return False",
              "signature": "is_no_effect(content: str, resource: Dict[str, Any]) -> bool",
              "full_signature": "is_no_effect(content: str, resource: Dict[str, Any]) -> bool",
              "annotations": ""
            },
            {
              "name": "is_trailing_cell",
              "line_number": 153,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "cell",
                  "line_number": 153,
                  "col_offset": 22,
                  "type": "Dict[str, Any]"
                },
                {
                  "name": "resource",
                  "line_number": 153,
                  "col_offset": 44,
                  "type": "Dict[str, Any]"
                }
              ],
              "return_type": "str",
              "body": "def is_trailing_cell(cell: Dict[str, Any], resource: Dict[str, Any]) -> str:\n    \"\"\"\n        Return true if the cell is a 'no effect cell' or not a 'code cell'\n    \"\"\"\n    logging.debug('Look for no trailing cells')\n    return cell['cell_type'] != 'code' or is_no_effect(cell['source'], resource)",
              "signature": "is_trailing_cell(cell: Dict[str, Any], resource: Dict[str, Any]) -> str",
              "full_signature": "is_trailing_cell(cell: Dict[str, Any], resource: Dict[str, Any]) -> str",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "helper",
          "file_path": "mlvtools/helper.py",
          "functions": [
            {
              "name": "to_cmd_param",
              "line_number": 18,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "variable",
                  "line_number": 18,
                  "col_offset": 18,
                  "type": "str"
                }
              ],
              "return_type": "str",
              "body": "def to_cmd_param(variable: str) -> str:\n    \"\"\"\n        Convert a variable in a command parameter format\n    \"\"\"\n    return variable.replace('_', '-')",
              "signature": "to_cmd_param(variable: str) -> str",
              "full_signature": "to_cmd_param(variable: str) -> str",
              "annotations": ""
            },
            {
              "name": "to_bash_variable",
              "line_number": 25,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "param",
                  "line_number": 25,
                  "col_offset": 22,
                  "type": "str"
                }
              ],
              "return_type": "str",
              "body": "def to_bash_variable(param: str) -> str:\n    \"\"\"\n        Convert a command variable in a bash variable\n    \"\"\"\n    return param.upper().replace('-', '_')",
              "signature": "to_bash_variable(param: str) -> str",
              "full_signature": "to_bash_variable(param: str) -> str",
              "annotations": ""
            },
            {
              "name": "to_method_name",
              "line_number": 32,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "name",
                  "line_number": 32,
                  "col_offset": 20,
                  "type": "str"
                }
              ],
              "return_type": "str",
              "body": "def to_method_name(name: str) -> str:\n    \"\"\"\n        Convert a file name without extension to a python method name\n    \"\"\"\n    return '{}{}'.format(MLV_PREFIX, to_lower_alphanum(name))",
              "signature": "to_method_name(name: str) -> str",
              "full_signature": "to_method_name(name: str) -> str",
              "annotations": ""
            },
            {
              "name": "to_script_name",
              "line_number": 39,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "file_name",
                  "line_number": 39,
                  "col_offset": 20,
                  "type": "str"
                }
              ],
              "return_type": "str",
              "body": "def to_script_name(file_name: str) -> str:\n    \"\"\"\n        Return a python script name deduced from a notebook file name\n    \"\"\"\n    without_extension = splitext(file_name)[0]\n    return '{}{}.py'.format(MLV_PREFIX, to_lower_alphanum(without_extension))",
              "signature": "to_script_name(file_name: str) -> str",
              "full_signature": "to_script_name(file_name: str) -> str",
              "annotations": ""
            },
            {
              "name": "to_lower_alphanum",
              "line_number": 47,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "file_name_no_ext",
                  "line_number": 47,
                  "col_offset": 23,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def to_lower_alphanum(file_name_no_ext: str):\n    \"\"\"\n        Convert a file name without extension to a lower case alphanumeric filename\n    \"\"\"\n    return re.sub(r'\\W+', '_', file_name_no_ext).lower()",
              "signature": "to_lower_alphanum(file_name_no_ext: str)",
              "full_signature": "to_lower_alphanum(file_name_no_ext: str)",
              "annotations": ""
            },
            {
              "name": "to_dvc_cmd_name",
              "line_number": 54,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "script_name",
                  "line_number": 54,
                  "col_offset": 21,
                  "type": "str"
                }
              ],
              "return_type": "str",
              "body": "def to_dvc_cmd_name(script_name: str) -> str:\n    \"\"\"\n        Return a dvc command name deduced from a python script name\n    \"\"\"\n    return '{}_dvc'.format(splitext(script_name)[0])",
              "signature": "to_dvc_cmd_name(script_name: str) -> str",
              "full_signature": "to_dvc_cmd_name(script_name: str) -> str",
              "annotations": ""
            },
            {
              "name": "to_dvc_meta_filename",
              "line_number": 61,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "python_script_path",
                  "line_number": 61,
                  "col_offset": 26,
                  "type": "str"
                }
              ],
              "return_type": "str",
              "body": "def to_dvc_meta_filename(python_script_path: str) -> str:\n    \"\"\"\n        Return a dvc meta file name deduced from a python script path\n    \"\"\"\n    without_extension = splitext(python_script_path)[0]\n    return f'{to_lower_alphanum(basename(without_extension))}.dvc'",
              "signature": "to_dvc_meta_filename(python_script_path: str) -> str",
              "full_signature": "to_dvc_meta_filename(python_script_path: str) -> str",
              "annotations": ""
            },
            {
              "name": "to_instructions_list",
              "line_number": 69,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "source",
                  "line_number": 69,
                  "col_offset": 26,
                  "type": "str"
                }
              ],
              "return_type": "List[str]",
              "body": "def to_instructions_list(source: str) -> List[str]:\n    \"\"\"\n        Convert a string of several instruction into a list of instructions\n    \"\"\"\n    return source.strip('\\n').split('\\n')",
              "signature": "to_instructions_list(source: str) -> List[str]",
              "full_signature": "to_instructions_list(source: str) -> List[str]",
              "annotations": ""
            },
            {
              "name": "to_sanitized_path",
              "line_number": 76,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "path",
                  "line_number": 76,
                  "col_offset": 23,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def to_sanitized_path(path: str):\n    \"\"\" Ensure path starts with / \"\"\"\n    return path if path.startswith(('/', './')) else f'./{path}'",
              "signature": "to_sanitized_path(path: str)",
              "full_signature": "to_sanitized_path(path: str)",
              "annotations": ""
            },
            {
              "name": "extract_type",
              "line_number": 84,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "type_name",
                  "line_number": 84,
                  "col_offset": 18,
                  "type": "str"
                }
              ],
              "return_type": "TypeInfo",
              "body": "def extract_type(type_name: str) -> TypeInfo:\n    \"\"\"\n        Extract type info (type name and is list) from docstring\n        type.\n        examples:\n            str => str, is_list=False\n            int => int, is_list=False\n            List[int] => int, is_list=True\n            list[str] => str, is_list=True\n\n    \"\"\"\n    if type_name:\n        is_list = False\n        type_name = type_name.strip()\n        match = re.match(r'^[L|l]ist(?:\\[(?P<type_name>\\w*)\\])?$', type_name)\n        if match:\n            is_list = True\n            type_name = 'str' if not match.group('type_name') else match.group('type_name')\n        return TypeInfo(type_name, is_list)\n    return TypeInfo(None, is_list=False)",
              "signature": "extract_type(type_name: str) -> TypeInfo",
              "full_signature": "extract_type(type_name: str) -> TypeInfo",
              "annotations": ""
            },
            {
              "name": "render_string_template",
              "line_number": 106,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "string_template",
                  "line_number": 106,
                  "col_offset": 28,
                  "type": "str"
                }
              ],
              "return_type": "str",
              "body": "def render_string_template(string_template: str, **kwargs) -> str:\n    \"\"\"\n        Render a Jinja string template\n    \"\"\"\n    return Environment(undefined=StrictUndefined).from_string(string_template).render(**kwargs)",
              "signature": "render_string_template(string_template: str) -> str",
              "full_signature": "render_string_template(string_template: str) -> str",
              "annotations": ""
            },
            {
              "name": "write_template",
              "line_number": 113,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "output_path",
                  "line_number": 113,
                  "col_offset": 20,
                  "type": null
                },
                {
                  "name": "template_path",
                  "line_number": 113,
                  "col_offset": 33,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def write_template(output_path, template_path: str, **kwargs):\n    \"\"\"\n        Write an executable output file using Jinja template.\n    \"\"\"\n    logging.info(f'Write command {output_path} using template {basename(template_path)}')\n    try:\n        makedirs(dirname(output_path), exist_ok=True)\n        with open(template_path, 'r') as template_fd, open(output_path, 'w') as fd:\n            content = render_string_template(template_fd.read(), **kwargs)\n            fd.write(content)\n        chmod(output_path, 0o755)\n    except IOError as e:\n        raise MlVToolException(f'Cannot create executable {output_path} using template {template_path}') from e\n    except UndefinedError as e:\n        raise MlVToolException(f'Cannot render {output_path} using template {template_path} due to undefined '\n                               f'variable: {e}') from e\n    except TemplateError as e:\n        raise MlVToolException(f'Cannot render {output_path} using template {template_path}') from e",
              "signature": "write_template(output_path, template_path: str)",
              "full_signature": "write_template(output_path, template_path: str)",
              "annotations": ""
            },
            {
              "name": "write_python_script",
              "line_number": 133,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "script_content",
                  "line_number": 133,
                  "col_offset": 25,
                  "type": "str"
                },
                {
                  "name": "output_path",
                  "line_number": 133,
                  "col_offset": 46,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def write_python_script(script_content: str, output_path: str):\n    \"\"\"\n        Write Python 3 generated code into an executable file\n        - use yapf for code format\n    \"\"\"\n    try:\n        makedirs(dirname(output_path), exist_ok=True)\n        formatted_script = FormatCode(script_content, style_config=f'{{ based_on_style: pep8, '\n                                                                   f'column_limit: {MAX_LINE_LENGTH} }}')\n        with open(output_path, 'w') as fd:\n            fd.write(formatted_script[0])\n        chmod(output_path, 0o755)\n    except SyntaxError as e:\n        raise MlVToolException(f'Cannot write generated Python, content is wrongly formatted: {script_content}') from e\n    except IOError as e:\n        raise MlVToolException(f'Cannot write generated Python script {output_path}') from e",
              "signature": "write_python_script(script_content: str, output_path: str)",
              "full_signature": "write_python_script(script_content: str, output_path: str)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "check_script",
          "file_path": "mlvtools/check_script.py",
          "functions": [
            {
              "name": "compare",
              "line_number": 15,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "notebook_path",
                  "line_number": 15,
                  "col_offset": 13,
                  "type": "str"
                },
                {
                  "name": "script_path",
                  "line_number": 15,
                  "col_offset": 33,
                  "type": "str"
                },
                {
                  "name": "conf",
                  "line_number": 15,
                  "col_offset": 51,
                  "type": "MlVToolConf"
                }
              ],
              "return_type": "bool",
              "body": "def compare(notebook_path: str, script_path: str, conf: MlVToolConf) -> bool:\n    \"\"\"\n        Compare the script obtained by notebook conversion using ipynb_to_python\n        with the actual script.\n    \"\"\"\n    generated_script = get_converted_script(notebook_path, conf)\n    generated_ast = get_ast(generated_script, name=notebook_path)\n\n    script_ast = get_ast_from_file(script_path)\n\n    return is_ast_equal(generated_ast, script_ast)",
              "signature": "compare(notebook_path: str, script_path: str, conf: MlVToolConf) -> bool",
              "full_signature": "compare(notebook_path: str, script_path: str, conf: MlVToolConf) -> bool",
              "annotations": ""
            },
            {
              "name": "run_consistency_check",
              "line_number": 28,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "notebook_path",
                  "line_number": 28,
                  "col_offset": 27,
                  "type": "str"
                },
                {
                  "name": "script_path",
                  "line_number": 28,
                  "col_offset": 47,
                  "type": "str"
                },
                {
                  "name": "conf",
                  "line_number": 28,
                  "col_offset": 65,
                  "type": "MlVToolConf"
                }
              ],
              "return_type": "bool",
              "body": "def run_consistency_check(notebook_path: str, script_path: str, conf: MlVToolConf) -> bool:\n    \"\"\"\n        Call comparison on notebook and script then display the result.\n    \"\"\"\n    logging.info(f'Run consistency check on ({notebook_path}, {script_path})')\n\n    if not exists(script_path):\n        logging.error(f'Script path {script_path} does not exists.')\n        return False\n\n    equals = compare(notebook_path, script_path, conf)\n    if equals:\n        logging.log(logging.WARNING + 1, f'Script content is the same for {basename(notebook_path)} '\n                                         f'and {basename(script_path)}')\n    else:\n        logging.error(f'Difference found between {notebook_path} and {script_path}.'\n                      f'Ensure notebook conversion is up to date (ipynb_to_python)')\n    return equals",
              "signature": "run_consistency_check(notebook_path: str, script_path: str, conf: MlVToolConf) -> bool",
              "full_signature": "run_consistency_check(notebook_path: str, script_path: str, conf: MlVToolConf) -> bool",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "export_pipeline",
          "file_path": "mlvtools/export_pipeline.py",
          "functions": [
            {
              "name": "get_dvc_files",
              "line_number": 23,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "dvc_target_file",
                  "line_number": 23,
                  "col_offset": 19,
                  "type": "str"
                }
              ],
              "return_type": "List[str]",
              "body": "def get_dvc_files(dvc_target_file: str) -> List[str]:\n    \"\"\"\n        Return the list of potential DVC meta file pipeline step.\n        DVC meta files are all located in the same directory for a given pipeline.\n        DVC file extension: .dvc\n    \"\"\"\n    if not exists(dvc_target_file):\n        raise MlVToolException(f'Targeted pipeline metadata step {dvc_target_file} does not exist')\n    return glob.glob(join(dirname(dvc_target_file), '*.dvc'))",
              "signature": "get_dvc_files(dvc_target_file: str) -> List[str]",
              "full_signature": "get_dvc_files(dvc_target_file: str) -> List[str]",
              "annotations": ""
            },
            {
              "name": "export_pipeline",
              "line_number": 34,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "dvc_meta_file",
                  "line_number": 34,
                  "col_offset": 21,
                  "type": "str"
                },
                {
                  "name": "output",
                  "line_number": 34,
                  "col_offset": 41,
                  "type": "str"
                },
                {
                  "name": "work_dir",
                  "line_number": 34,
                  "col_offset": 54,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def export_pipeline(dvc_meta_file: str, output: str, work_dir: str):\n    \"\"\"\n     Generate an executable script to run a whole pipeline\n    \"\"\"\n    logging.info(f'Export pipeline from step {dvc_meta_file} to {output}')\n    logging.debug(f'Work directory {work_dir}')\n\n    ordered_dvc_metas = get_dvc_dependencies(dvc_meta_file, get_dvc_files(dvc_meta_file))\n\n    template_data = {'work_dir': work_dir, 'cmds': [dvc_meta.cmd for dvc_meta in ordered_dvc_metas]}\n    logging.debug(f'Template data: {template_data}')\n\n    templates_path = join(CURRENT_DIR, 'templates', PIPELINE_EXPORT_TEMPLATE_NAME)\n    write_template(output, templates_path, info=template_data)\n    logging.log(logging.WARNING + 1, f'Pipeline successfully exported in {abspath(output)}')",
              "signature": "export_pipeline(dvc_meta_file: str, output: str, work_dir: str)",
              "full_signature": "export_pipeline(dvc_meta_file: str, output: str, work_dir: str)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "parse",
          "file_path": "mlvtools/diff/parse.py",
          "functions": [
            {
              "name": "get_ast",
              "line_number": 6,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "content",
                  "line_number": 6,
                  "col_offset": 13,
                  "type": "str"
                },
                {
                  "name": "name",
                  "line_number": 6,
                  "col_offset": 27,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def get_ast(content: str, name: str = 'undefined'):\n    \"\"\"\n        Return ast tree of the given python content\n    \"\"\"\n    try:\n        return ast.parse(content, filename=name)\n    except SyntaxError as e:\n        raise MlVToolException(f'Invalid python format for file {name}: {e}') from e\n    except Exception as e:\n        raise MlVToolException(f'Cannot extract ast tree{f\" {name}\" if name else \"\"}: {e}') from e",
              "signature": "get_ast(content: str, name: str)",
              "full_signature": "get_ast(content: str, name: str)",
              "annotations": ""
            },
            {
              "name": "get_ast_from_file",
              "line_number": 18,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "file_path",
                  "line_number": 18,
                  "col_offset": 23,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def get_ast_from_file(file_path: str):\n    \"\"\"\n        Read provided file then return the corresponding ast tree\n    \"\"\"\n    try:\n        with open(file_path, 'r') as fd:\n            return get_ast(fd.read(), file_path)\n    except IOError as e:\n        raise MlVToolException(f'Cannot read file {file_path} for ast tree extraction') from e",
              "signature": "get_ast_from_file(file_path: str)",
              "full_signature": "get_ast_from_file(file_path: str)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "dvc_parser",
          "file_path": "mlvtools/mlv_dvc/dvc_parser.py",
          "functions": [
            {
              "name": "get_dvc_meta",
              "line_number": 14,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "dvc_meta_file",
                  "line_number": 14,
                  "col_offset": 18,
                  "type": "str"
                }
              ],
              "return_type": "DvcMeta",
              "body": "def get_dvc_meta(dvc_meta_file: str) -> DvcMeta:\n    \"\"\"\n        Get DVC meta from a DVC meta file\n    \"\"\"\n    logging.debug(f'Get DVC meta from {dvc_meta_file}')\n    try:\n        with open(dvc_meta_file, 'r') as fd:\n            raw_data = yaml.safe_load(fd.read())\n            deps = [v['path'] for v in raw_data.get('deps', [])]\n            outs = [v['path'] for v in raw_data.get('outs', [])]\n            meta = DvcMeta(basename(dvc_meta_file), raw_data.get('cmd', ''), deps, outs)\n            logging.debug(f'Meta for {dvc_meta_file}: {meta}')\n            return meta\n    except (yaml.error.YAMLError, AttributeError) as e:\n        raise MlVToolException(f'Cannot load DVC meta file {dvc_meta_file}. Wrong format') from e\n    except IOError as e:\n        raise MlVToolException(f'Cannot load DVC meta file {dvc_meta_file}') from e",
              "signature": "get_dvc_meta(dvc_meta_file: str) -> DvcMeta",
              "full_signature": "get_dvc_meta(dvc_meta_file: str) -> DvcMeta",
              "annotations": ""
            },
            {
              "name": "get_dvc_dependencies",
              "line_number": 47,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "target_file_path",
                  "line_number": 47,
                  "col_offset": 26,
                  "type": "str"
                },
                {
                  "name": "dvc_files",
                  "line_number": 47,
                  "col_offset": 49,
                  "type": "List[str]"
                }
              ],
              "return_type": "List[DvcMeta]",
              "body": "def get_dvc_dependencies(target_file_path: str, dvc_files: List[str]) -> List[DvcMeta]:\n    \"\"\"\n        Get ordered DVC meta needed to complete a DVC target step\n    \"\"\"\n    logging.info(f'Get DVC dependencies for {target_file_path}')\n    logging.debug(f'DVC files list {dvc_files}')\n    dvc_metas = get_meta_info(dvc_files)\n    target_step = get_dvc_meta(target_file_path)\n    dag = networkx.DiGraph()\n    for step in dvc_metas.values():\n        dag.add_node(step.name, step=step)\n        for dep in step.deps:\n            if dep not in dvc_metas:\n                continue\n            dag.add_node(dvc_metas[dep].name, step=dvc_metas[dep])\n            dag.add_edge(step.name, dvc_metas[dep].name, name=dep)\n    all_nodes = dict(dag.nodes(data='step'))\n    ordered_dependencies = [all_nodes[name] for name in networkx.dfs_postorder_nodes(dag, target_step.name)]\n    logging.debug(f'Ordered dependencies: {ordered_dependencies}')\n    return ordered_dependencies",
              "signature": "get_dvc_dependencies(target_file_path: str, dvc_files: List[str]) -> List[DvcMeta]",
              "full_signature": "get_dvc_dependencies(target_file_path: str, dvc_files: List[str]) -> List[DvcMeta]",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "parse",
          "file_path": "mlvtools/docstring_helpers/parse.py",
          "functions": [
            {
              "name": "parse_docstring",
              "line_number": 208,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "docstring_str",
                  "line_number": 208,
                  "col_offset": 21,
                  "type": "str"
                }
              ],
              "return_type": "Docstring",
              "body": "def parse_docstring(docstring_str: str) -> Docstring:\n    try:\n        docstring = dc_parse(docstring_str, style=Style.rest)\n    except ParseError as e:\n        raise MlVToolException(f'Docstring format error. {e}') from e\n    return docstring",
              "signature": "parse_docstring(docstring_str: str) -> Docstring",
              "full_signature": "parse_docstring(docstring_str: str) -> Docstring",
              "annotations": ""
            },
            {
              "name": "resolve_docstring",
              "line_number": 216,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "docstring",
                  "line_number": 216,
                  "col_offset": 23,
                  "type": "str"
                },
                {
                  "name": "docstring_conf",
                  "line_number": 216,
                  "col_offset": 39,
                  "type": "dict"
                }
              ],
              "return_type": "str",
              "body": "def resolve_docstring(docstring: str, docstring_conf: dict) -> str:\n    \"\"\"\n        Use jinja to resolve docstring template using user custom configuration\n    \"\"\"\n    try:\n        return render_string_template(docstring, conf=docstring_conf)\n    except jinja2.exceptions.TemplateError as e:\n        raise MlVToolException(f'Cannot resolve docstring using Jinja, {e}') from e",
              "signature": "resolve_docstring(docstring: str, docstring_conf: dict) -> str",
              "full_signature": "resolve_docstring(docstring: str, docstring_conf: dict) -> str",
              "annotations": ""
            }
          ],
          "classes": [
            {
              "name": "DocstringDvc",
              "methods": [
                {
                  "name": "__init__",
                  "line_number": 18,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "self",
                      "line_number": 18,
                      "col_offset": 18,
                      "type": null
                    },
                    {
                      "name": "file_path",
                      "line_number": 18,
                      "col_offset": 24,
                      "type": "str"
                    },
                    {
                      "name": "related_param",
                      "line_number": 18,
                      "col_offset": 40,
                      "type": "str"
                    }
                  ],
                  "return_type": null,
                  "body": "def __init__(self, file_path: str, related_param: str = None):\n        self.related_param = related_param\n        self.file_path = file_path",
                  "signature": "DocstringDvc.__init__(self, file_path: str, related_param: str)",
                  "full_signature": "DocstringDvc.__init__(self, file_path: str, related_param: str)",
                  "annotations": "",
                  "is_constructor": true
                },
                {
                  "name": "meta_checks",
                  "line_number": 27,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "params",
                      "line_number": 27,
                      "col_offset": 21,
                      "type": "Dict[str, Optional[str]]"
                    },
                    {
                      "name": "args",
                      "line_number": 27,
                      "col_offset": 55,
                      "type": "List[str]"
                    },
                    {
                      "name": "description",
                      "line_number": 27,
                      "col_offset": 72,
                      "type": "str"
                    },
                    {
                      "name": "expected_key",
                      "line_number": 27,
                      "col_offset": 90,
                      "type": "str"
                    }
                  ],
                  "return_type": null,
                  "body": "def meta_checks(params: Dict[str, Optional[str]], args: List[str], description: str, expected_key: str):\n        if len(args) == 0:\n            raise MlVToolException('Cannot parse empty DocstringDVC')\n        if len(args) > 2:\n            raise MlVToolException(f'Invalid syntax: {args}. Expected :dvc-[in|out] [related_param]?: {{file_path}}')\n        if args[0] != expected_key:\n            raise MlVToolException('Receive bad parameter {}'.format(args[0]))\n\n        if not description:\n            raise MlVToolException(f'Not path given for {args}')\n\n        related_param = args[1] if len(args) == 2 else None\n\n        if related_param and related_param not in params:\n            raise MlVToolException(f'Cannot find related parameter for {related_param} in {args}')\n\n        if related_param and params[related_param] not in (None, 'str'):\n            raise MlVToolException(f'Unsupported type {params[related_param]} for {args}. Discard.')",
                  "signature": "DocstringDvc.meta_checks(params: Dict[str, Optional[str]], args: List[str], description: str, expected_key: str)",
                  "full_signature": "DocstringDvc.meta_checks(params: Dict[str, Optional[str]], args: List[str], description: str, expected_key: str)",
                  "annotations": "",
                  "is_constructor": false
                }
              ],
              "superclasses": [],
              "fields": []
            },
            {
              "name": "DocstringDvcIn",
              "methods": [
                {
                  "name": "__init__",
                  "line_number": 56,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "self",
                      "line_number": 56,
                      "col_offset": 18,
                      "type": null
                    },
                    {
                      "name": "path",
                      "line_number": 56,
                      "col_offset": 24,
                      "type": "str"
                    },
                    {
                      "name": "related_param",
                      "line_number": 56,
                      "col_offset": 35,
                      "type": "str"
                    }
                  ],
                  "return_type": null,
                  "body": "def __init__(self, path: str, related_param: str = None):\n        super().__init__(path, related_param)",
                  "signature": "DocstringDvcIn.__init__(self, path: str, related_param: str)",
                  "full_signature": "DocstringDvcIn.__init__(self, path: str, related_param: str)",
                  "annotations": "",
                  "is_constructor": true
                },
                {
                  "name": "from_meta",
                  "line_number": 60,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "params",
                      "line_number": 60,
                      "col_offset": 19,
                      "type": "Dict[str, Optional[str]]"
                    },
                    {
                      "name": "args",
                      "line_number": 60,
                      "col_offset": 53,
                      "type": "List[str]"
                    },
                    {
                      "name": "description",
                      "line_number": 60,
                      "col_offset": 70,
                      "type": "str"
                    }
                  ],
                  "return_type": "'DocstringDvcIn'",
                  "body": "def from_meta(params: Dict[str, Optional[str]], args: List[str], description: str) -> 'DocstringDvcIn':\n        DocstringDvc.meta_checks(params, args, description, DocstringDvcIn.DVC_IN_KEY)\n        return DocstringDvcIn(description, args[1] if len(args) == 2 else None)",
                  "signature": "DocstringDvcIn.from_meta(params: Dict[str, Optional[str]], args: List[str], description: str) -> 'DocstringDvcIn'",
                  "full_signature": "DocstringDvcIn.from_meta(params: Dict[str, Optional[str]], args: List[str], description: str) -> 'DocstringDvcIn'",
                  "annotations": "",
                  "is_constructor": false
                }
              ],
              "superclasses": [
                "DocstringDvc"
              ],
              "fields": [
                "DVC_IN_KEY"
              ]
            },
            {
              "name": "DocstringDvcOut",
              "methods": [
                {
                  "name": "__init__",
                  "line_number": 73,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "self",
                      "line_number": 73,
                      "col_offset": 18,
                      "type": null
                    },
                    {
                      "name": "path",
                      "line_number": 73,
                      "col_offset": 24,
                      "type": "str"
                    },
                    {
                      "name": "related_param",
                      "line_number": 73,
                      "col_offset": 35,
                      "type": "str"
                    }
                  ],
                  "return_type": null,
                  "body": "def __init__(self, path: str, related_param: str = None):\n        super().__init__(path, related_param)",
                  "signature": "DocstringDvcOut.__init__(self, path: str, related_param: str)",
                  "full_signature": "DocstringDvcOut.__init__(self, path: str, related_param: str)",
                  "annotations": "",
                  "is_constructor": true
                },
                {
                  "name": "from_meta",
                  "line_number": 77,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "params",
                      "line_number": 77,
                      "col_offset": 19,
                      "type": "Dict[str, Optional[str]]"
                    },
                    {
                      "name": "args",
                      "line_number": 77,
                      "col_offset": 53,
                      "type": "List[str]"
                    },
                    {
                      "name": "description",
                      "line_number": 77,
                      "col_offset": 70,
                      "type": "str"
                    }
                  ],
                  "return_type": "'DocstringDvcOut'",
                  "body": "def from_meta(params: Dict[str, Optional[str]], args: List[str], description: str) -> 'DocstringDvcOut':\n        DocstringDvc.meta_checks(params, args, description, DocstringDvcOut.DVC_OUT_KEY)\n        return DocstringDvcOut(description, args[1] if len(args) == 2 else None)",
                  "signature": "DocstringDvcOut.from_meta(params: Dict[str, Optional[str]], args: List[str], description: str) -> 'DocstringDvcOut'",
                  "full_signature": "DocstringDvcOut.from_meta(params: Dict[str, Optional[str]], args: List[str], description: str) -> 'DocstringDvcOut'",
                  "annotations": "",
                  "is_constructor": false
                }
              ],
              "superclasses": [
                "DocstringDvc"
              ],
              "fields": [
                "DVC_OUT_KEY"
              ]
            },
            {
              "name": "DocstringDvcOutPersist",
              "methods": [
                {
                  "name": "__init__",
                  "line_number": 90,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "self",
                      "line_number": 90,
                      "col_offset": 18,
                      "type": null
                    },
                    {
                      "name": "path",
                      "line_number": 90,
                      "col_offset": 24,
                      "type": "str"
                    },
                    {
                      "name": "related_param",
                      "line_number": 90,
                      "col_offset": 35,
                      "type": "str"
                    }
                  ],
                  "return_type": null,
                  "body": "def __init__(self, path: str, related_param: str = None):\n        super().__init__(path, related_param)",
                  "signature": "DocstringDvcOutPersist.__init__(self, path: str, related_param: str)",
                  "full_signature": "DocstringDvcOutPersist.__init__(self, path: str, related_param: str)",
                  "annotations": "",
                  "is_constructor": true
                },
                {
                  "name": "from_meta",
                  "line_number": 94,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "params",
                      "line_number": 94,
                      "col_offset": 19,
                      "type": "Dict[str, Optional[str]]"
                    },
                    {
                      "name": "args",
                      "line_number": 94,
                      "col_offset": 53,
                      "type": "List[str]"
                    },
                    {
                      "name": "description",
                      "line_number": 94,
                      "col_offset": 70,
                      "type": "str"
                    }
                  ],
                  "return_type": "'DocstringDvcOutPersist'",
                  "body": "def from_meta(params: Dict[str, Optional[str]], args: List[str], description: str) -> 'DocstringDvcOutPersist':\n        DocstringDvc.meta_checks(params, args, description, DocstringDvcOutPersist.DVC_OUT_PERSIST_KEY)\n        return DocstringDvcOutPersist(description, args[1] if len(args) == 2 else None)",
                  "signature": "DocstringDvcOutPersist.from_meta(params: Dict[str, Optional[str]], args: List[str], description: str) -> 'DocstringDvcOutPersist'",
                  "full_signature": "DocstringDvcOutPersist.from_meta(params: Dict[str, Optional[str]], args: List[str], description: str) -> 'DocstringDvcOutPersist'",
                  "annotations": "",
                  "is_constructor": false
                }
              ],
              "superclasses": [
                "DocstringDvc"
              ],
              "fields": [
                "DVC_OUT_PERSIST_KEY"
              ]
            },
            {
              "name": "DocstringDvcExtra",
              "methods": [
                {
                  "name": "__init__",
                  "line_number": 108,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "self",
                      "line_number": 108,
                      "col_offset": 18,
                      "type": null
                    },
                    {
                      "name": "extra",
                      "line_number": 108,
                      "col_offset": 24,
                      "type": "str"
                    }
                  ],
                  "return_type": null,
                  "body": "def __init__(self, extra: str):\n        self.extra = extra",
                  "signature": "DocstringDvcExtra.__init__(self, extra: str)",
                  "full_signature": "DocstringDvcExtra.__init__(self, extra: str)",
                  "annotations": "",
                  "is_constructor": true
                },
                {
                  "name": "from_meta",
                  "line_number": 112,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "args",
                      "line_number": 112,
                      "col_offset": 19,
                      "type": "List[str]"
                    },
                    {
                      "name": "description",
                      "line_number": 112,
                      "col_offset": 36,
                      "type": "str"
                    }
                  ],
                  "return_type": "'DocstringDvcExtra'",
                  "body": "def from_meta(args: List[str], description: str) -> 'DocstringDvcExtra':\n        if len(args) != 1 or not description:\n            raise MlVToolException(f'Docstring dvc-extra invalid syntax: {args}:{description}.'\n                                   f'Expected :dvc-extra: {{python_other_param}}')\n        if args[0] != DocstringDvcExtra.DVC_EXTRA_KEY:\n            raise MlVToolException(f'Receive bad parameter for {DocstringDvcExtra.DVC_EXTRA_KEY} {args[0]}')\n        return DocstringDvcExtra(description)",
                  "signature": "DocstringDvcExtra.from_meta(args: List[str], description: str) -> 'DocstringDvcExtra'",
                  "full_signature": "DocstringDvcExtra.from_meta(args: List[str], description: str) -> 'DocstringDvcExtra'",
                  "annotations": "",
                  "is_constructor": false
                }
              ],
              "superclasses": [],
              "fields": [
                "DVC_EXTRA_KEY"
              ]
            },
            {
              "name": "DocstringDvcMetaFile",
              "methods": [
                {
                  "name": "__init__",
                  "line_number": 130,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "self",
                      "line_number": 130,
                      "col_offset": 18,
                      "type": null
                    },
                    {
                      "name": "file_name",
                      "line_number": 130,
                      "col_offset": 24,
                      "type": "str"
                    }
                  ],
                  "return_type": null,
                  "body": "def __init__(self, file_name: str):\n        self.file_name = file_name",
                  "signature": "DocstringDvcMetaFile.__init__(self, file_name: str)",
                  "full_signature": "DocstringDvcMetaFile.__init__(self, file_name: str)",
                  "annotations": "",
                  "is_constructor": true
                },
                {
                  "name": "from_meta",
                  "line_number": 134,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "args",
                      "line_number": 134,
                      "col_offset": 19,
                      "type": "List[str]"
                    },
                    {
                      "name": "description",
                      "line_number": 134,
                      "col_offset": 36,
                      "type": "str"
                    }
                  ],
                  "return_type": "'DocstringDvcMetaFile'",
                  "body": "def from_meta(args: List[str], description: str) -> 'DocstringDvcMetaFile':\n        if len(args) != 1 or not description:\n            raise MlVToolException(f'Docstring dvc-meta-file invalid syntax: {args}:{description}.'\n                                   f'Expected :dvc-meta-file: {{meta_file_name}}')\n        if args[0] != DocstringDvcMetaFile.DVC_META_FILE_KEY:\n            raise MlVToolException(f'Receive bad parameter for {DocstringDvcMetaFile.DVC_META_FILE_KEY} {args[0]}')\n        description = description if description.endswith('.dvc') else f'{description}.dvc'\n        return DocstringDvcMetaFile(description)",
                  "signature": "DocstringDvcMetaFile.from_meta(args: List[str], description: str) -> 'DocstringDvcMetaFile'",
                  "full_signature": "DocstringDvcMetaFile.from_meta(args: List[str], description: str) -> 'DocstringDvcMetaFile'",
                  "annotations": "",
                  "is_constructor": false
                }
              ],
              "superclasses": [],
              "fields": [
                "DVC_META_FILE_KEY"
              ]
            },
            {
              "name": "DocstringDvcCommand",
              "methods": [
                {
                  "name": "__init__",
                  "line_number": 154,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "self",
                      "line_number": 154,
                      "col_offset": 18,
                      "type": null
                    },
                    {
                      "name": "cmd",
                      "line_number": 154,
                      "col_offset": 24,
                      "type": "str"
                    }
                  ],
                  "return_type": null,
                  "body": "def __init__(self, cmd: str):\n        self.cmd = cmd",
                  "signature": "DocstringDvcCommand.__init__(self, cmd: str)",
                  "full_signature": "DocstringDvcCommand.__init__(self, cmd: str)",
                  "annotations": "",
                  "is_constructor": true
                },
                {
                  "name": "from_meta",
                  "line_number": 158,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "args",
                      "line_number": 158,
                      "col_offset": 19,
                      "type": "List[str]"
                    },
                    {
                      "name": "description",
                      "line_number": 158,
                      "col_offset": 36,
                      "type": "str"
                    }
                  ],
                  "return_type": "'DocstringDvcCommand'",
                  "body": "def from_meta(args: List[str], description: str) -> 'DocstringDvcCommand':\n        if len(args) != 1 or not description:\n            raise MlVToolException(f'Docstring dvc-cmd invalid syntax: {args}:{description}.'\n                                   f'Expected :dvc-cmd: {{dvc_command}}')\n        if args[0] != DocstringDvcCommand.DVC_CMD_KEY:\n            raise MlVToolException(f'Receive bad parameter for {DocstringDvcCommand.DVC_CMD_KEY} {args[0]}')\n        return DocstringDvcCommand(description)",
                  "signature": "DocstringDvcCommand.from_meta(args: List[str], description: str) -> 'DocstringDvcCommand'",
                  "full_signature": "DocstringDvcCommand.from_meta(args: List[str], description: str) -> 'DocstringDvcCommand'",
                  "annotations": "",
                  "is_constructor": false
                }
              ],
              "superclasses": [],
              "fields": [
                "DVC_CMD_KEY"
              ]
            }
          ]
        },
        {
          "name": "extract",
          "file_path": "mlvtools/docstring_helpers/extract.py",
          "functions": [
            {
              "name": "extract_docstring",
              "line_number": 12,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "cell_content",
                  "line_number": 12,
                  "col_offset": 23,
                  "type": "str"
                }
              ],
              "return_type": "str",
              "body": "def extract_docstring(cell_content: str) -> str:\n    \"\"\" Extract a docstring from a cell content \"\"\"\n    logging.info('Extract docstring from cell content')\n    logging.debug(f'Cell content {cell_content}')\n    docstring = ''\n    try:\n        root = get_ast(cell_content)\n    except SyntaxError as e:\n        raise MlVToolException(f'Invalid python cell format: {cell_content}') from e\n    for node in ast.walk(root):\n        if isinstance(node, ast.Module):\n            docstring = ast.get_docstring(node)\n            break\n    return docstring",
              "signature": "extract_docstring(cell_content: str) -> str",
              "full_signature": "extract_docstring(cell_content: str) -> str",
              "annotations": ""
            },
            {
              "name": "extract_docstring_from_file",
              "line_number": 32,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "input_path",
                  "line_number": 32,
                  "col_offset": 33,
                  "type": "str"
                },
                {
                  "name": "docstring_conf",
                  "line_number": 32,
                  "col_offset": 50,
                  "type": "dict"
                }
              ],
              "return_type": "DocstringInfo",
              "body": "def extract_docstring_from_file(input_path: str, docstring_conf: dict = None) -> DocstringInfo:\n    \"\"\"\n        Extract method docstring information (docstring, method_name, input_path)\n        The provided python script must have one and only one method\n        The extracted docstring is parsed and returned in docstring info\n    \"\"\"\n    logging.info(f'Extract docstring from \"{input_path}\".')\n    try:\n        with open(input_path, 'r') as fd:\n            root = ast.parse(fd.read())\n    except FileNotFoundError as e:\n        raise MlVToolException(\n            f'Python input script {input_path} not found.') from e\n    except SyntaxError as e:\n        raise MlVToolException(f'Invalid python script format: {input_path}') from e\n\n    for node in ast.walk(root):\n        if isinstance(node, ast.FunctionDef):\n            method_name = node.name\n            docstring_str = ast.get_docstring(node)\n            if docstring_conf:\n                docstring_str = resolve_docstring(docstring_str, docstring_conf)\n            docstring = dc_parse(docstring_str)\n            break\n    else:\n        logging.error(f'Not method found in {input_path}')\n        raise MlVToolException(f'Not method found in {input_path}')\n\n    logging.debug(f'Docstring extracted from method {method_name}: {docstring_str}')\n    docstring_info = DocstringInfo(method_name=method_name,\n                                   docstring=docstring,\n                                   repr=docstring_str,\n                                   file_path=input_path)\n    return docstring_info",
              "signature": "extract_docstring_from_file(input_path: str, docstring_conf: dict) -> DocstringInfo",
              "full_signature": "extract_docstring_from_file(input_path: str, docstring_conf: dict) -> DocstringInfo",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "conf",
          "file_path": "mlvtools/conf/conf.py",
          "functions": [
            {
              "name": "load_conf_or_default",
              "line_number": 84,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "conf_path",
                  "line_number": 84,
                  "col_offset": 26,
                  "type": "str"
                },
                {
                  "name": "working_directory",
                  "line_number": 84,
                  "col_offset": 42,
                  "type": null
                }
              ],
              "return_type": "MlVToolConf",
              "body": "def load_conf_or_default(conf_path: str, working_directory) -> MlVToolConf:\n    \"\"\" Load the configuration file if present \"\"\"\n    if exists(conf_path):\n        logging.info(f'Load configuration from {conf_path}')\n        return MlVToolConf.load_from_file(conf_path, working_directory)\n    logging.info('No configuration found. Use default.')\n    return MlVToolConf(top_directory=working_directory)",
              "signature": "load_conf_or_default(conf_path: str, working_directory) -> MlVToolConf",
              "full_signature": "load_conf_or_default(conf_path: str, working_directory) -> MlVToolConf",
              "annotations": ""
            },
            {
              "name": "get_script_output_path",
              "line_number": 93,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "notebook_path",
                  "line_number": 93,
                  "col_offset": 28,
                  "type": "str"
                },
                {
                  "name": "conf",
                  "line_number": 93,
                  "col_offset": 48,
                  "type": "MlVToolConf"
                }
              ],
              "return_type": "str",
              "body": "def get_script_output_path(notebook_path: str, conf: MlVToolConf) -> str:\n    \"\"\" Generate python script path according to conf and notebook file name \"\"\"\n    file_name = to_script_name(basename(notebook_path))\n    return join(conf.top_directory, conf.path.python_script_root_dir, file_name)",
              "signature": "get_script_output_path(notebook_path: str, conf: MlVToolConf) -> str",
              "full_signature": "get_script_output_path(notebook_path: str, conf: MlVToolConf) -> str",
              "annotations": ""
            },
            {
              "name": "get_dvc_cmd_output_path",
              "line_number": 99,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "script_path",
                  "line_number": 99,
                  "col_offset": 29,
                  "type": "str"
                },
                {
                  "name": "conf",
                  "line_number": 99,
                  "col_offset": 47,
                  "type": "MlVToolConf"
                }
              ],
              "return_type": "str",
              "body": "def get_dvc_cmd_output_path(script_path: str, conf: MlVToolConf) -> str:\n    \"\"\" Generate dvc command path according to conf and python script file name \"\"\"\n    file_name = to_dvc_cmd_name(basename(script_path))\n    return join(conf.top_directory, conf.path.dvc_cmd_root_dir, file_name)",
              "signature": "get_dvc_cmd_output_path(script_path: str, conf: MlVToolConf) -> str",
              "full_signature": "get_dvc_cmd_output_path(script_path: str, conf: MlVToolConf) -> str",
              "annotations": ""
            },
            {
              "name": "get_dvc_metadata_output_path",
              "line_number": 105,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "script_path",
                  "line_number": 105,
                  "col_offset": 34,
                  "type": "str"
                },
                {
                  "name": "conf",
                  "line_number": 105,
                  "col_offset": 52,
                  "type": "MlVToolConf"
                }
              ],
              "return_type": "str",
              "body": "def get_dvc_metadata_output_path(script_path: str, conf: MlVToolConf) -> str:\n    \"\"\" Generate dvc metadata path according to conf and python script file name \"\"\"\n    file_name = to_dvc_meta_filename(basename(script_path))\n    return join(conf.top_directory, conf.path.dvc_metadata_root_dir, file_name)",
              "signature": "get_dvc_metadata_output_path(script_path: str, conf: MlVToolConf) -> str",
              "full_signature": "get_dvc_metadata_output_path(script_path: str, conf: MlVToolConf) -> str",
              "annotations": ""
            },
            {
              "name": "get_conf_file_default_path",
              "line_number": 111,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "work_dir",
                  "line_number": 111,
                  "col_offset": 32,
                  "type": "str"
                }
              ],
              "return_type": "str",
              "body": "def get_conf_file_default_path(work_dir: str) -> str:\n    return join(work_dir, DEFAULT_CONF_FILENAME)",
              "signature": "get_conf_file_default_path(work_dir: str) -> str",
              "full_signature": "get_conf_file_default_path(work_dir: str) -> str",
              "annotations": ""
            },
            {
              "name": "load_docstring_conf",
              "line_number": 115,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "docstring_conf_path",
                  "line_number": 115,
                  "col_offset": 25,
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "body": "def load_docstring_conf(docstring_conf_path: str) -> dict:\n    \"\"\" Load a Yaml format docstring configuration \"\"\"\n    try:\n        logging.info(f'Load docstring configuration from {docstring_conf_path}')\n        with open(docstring_conf_path, 'r') as fd:\n            return yaml.safe_load(fd)\n    except yaml.YAMLError as e:\n        raise MlVToolConfException(f'Cannot load docstring conf {docstring_conf_path}. Format error {e}.') from e\n    except IOError as e:\n        raise MlVToolConfException(f'Cannot load file {docstring_conf_path}. IOError {e}') from e",
              "signature": "load_docstring_conf(docstring_conf_path: str) -> dict",
              "full_signature": "load_docstring_conf(docstring_conf_path: str) -> dict",
              "annotations": ""
            }
          ],
          "classes": [
            {
              "name": "MlVToolConf",
              "methods": [
                {
                  "name": "get_top_directory_raw_data",
                  "line_number": 66,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "top_dir",
                      "line_number": 66,
                      "col_offset": 36,
                      "type": "str"
                    }
                  ],
                  "return_type": "dict",
                  "body": "def get_top_directory_raw_data(top_dir: str) -> dict:\n        return {'top_directory': top_dir}",
                  "signature": "MlVToolConf.get_top_directory_raw_data(top_dir: str) -> dict",
                  "full_signature": "MlVToolConf.get_top_directory_raw_data(top_dir: str) -> dict",
                  "annotations": "",
                  "is_constructor": false
                },
                {
                  "name": "load_from_file",
                  "line_number": 70,
                  "col_offset": 9,
                  "parameters": [
                    {
                      "name": "file_path",
                      "line_number": 70,
                      "col_offset": 24,
                      "type": "str"
                    },
                    {
                      "name": "working_directory",
                      "line_number": 70,
                      "col_offset": 40,
                      "type": null
                    }
                  ],
                  "return_type": "'MlVToolConf'",
                  "body": "def load_from_file(file_path: str, working_directory) -> 'MlVToolConf':\n        try:\n            with open(file_path, 'r') as fd:\n                conf_raw_data = json.load(fd)\n            conf_raw_data.update(MlVToolConf.get_top_directory_raw_data(working_directory))\n            return MlVToolConf.parse_obj(conf_raw_data)\n        except JSONDecodeError as e:\n            raise MlVToolConfException(f'Cannot load conf from file {file_path}. Wrong format') from e\n        except ValidationError as e:\n            raise MlVToolConfException(f'Cannot load conf from file {file_path}. Validation error') from e\n        except IOError as e:\n            raise MlVToolConfException(f'Cannot load conf from file {file_path}') from e",
                  "signature": "MlVToolConf.load_from_file(file_path: str, working_directory) -> 'MlVToolConf'",
                  "full_signature": "MlVToolConf.load_from_file(file_path: str, working_directory) -> 'MlVToolConf'",
                  "annotations": "",
                  "is_constructor": false
                }
              ],
              "superclasses": [
                "BaseModel"
              ],
              "fields": []
            }
          ]
        },
        {
          "name": "test_helpers",
          "file_path": "tests/unit/test_helpers.py",
          "functions": [
            {
              "name": "check_write_template_error_case",
              "line_number": 164,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "template_path",
                  "line_number": 164,
                  "col_offset": 37,
                  "type": "str"
                },
                {
                  "name": "data",
                  "line_number": 164,
                  "col_offset": 57,
                  "type": "dict"
                },
                {
                  "name": "exp_error",
                  "line_number": 164,
                  "col_offset": 69,
                  "type": "Exception"
                }
              ],
              "return_type": null,
              "body": "def check_write_template_error_case(template_path: str, data: dict, exp_error: Exception):\n    with TemporaryDirectory() as tmp_dir:\n        output_path = join(tmp_dir, 'my_exe.sh')\n        with pytest.raises(MlVToolException) as e:\n            write_template(output_path, template_path, **data)\n    assert isinstance(e.value.__cause__, exp_error)",
              "signature": "check_write_template_error_case(template_path: str, data: dict, exp_error: Exception)",
              "full_signature": "check_write_template_error_case(template_path: str, data: dict, exp_error: Exception)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "test_check_consitency",
          "file_path": "tests/unit/test_check_consitency.py",
          "functions": [
            {
              "name": "create_notebook_and_convert_it",
              "line_number": 19,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "cells",
                  "line_number": 19,
                  "col_offset": 36,
                  "type": null
                },
                {
                  "name": "script_name",
                  "line_number": 19,
                  "col_offset": 43,
                  "type": null
                },
                {
                  "name": "conf",
                  "line_number": 19,
                  "col_offset": 56,
                  "type": null
                },
                {
                  "name": "work_dir",
                  "line_number": 19,
                  "col_offset": 62,
                  "type": null
                }
              ],
              "return_type": "str",
              "body": "def create_notebook_and_convert_it(cells, script_name, conf, work_dir) -> str:\n    \"\"\"\n        Create a notebook from cells then convert it into a python script\n    \"\"\"\n    notebook_path = gen_notebook(tmp_dir=work_dir, file_name='test.ipynb', docstring=None, cells=cells)\n    script_base_path = join(work_dir, script_name)\n    export_to_script(notebook_path, script_base_path, conf)\n    return notebook_path, script_base_path",
              "signature": "create_notebook_and_convert_it(cells, script_name, conf, work_dir) -> str",
              "full_signature": "create_notebook_and_convert_it(cells, script_name, conf, work_dir) -> str",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "utils",
          "file_path": "tests/helpers/utils.py",
          "functions": [
            {
              "name": "gen_notebook",
              "line_number": 10,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "cells",
                  "line_number": 10,
                  "col_offset": 18,
                  "type": "List[Tuple[str, str]]"
                },
                {
                  "name": "tmp_dir",
                  "line_number": 10,
                  "col_offset": 48,
                  "type": "str"
                },
                {
                  "name": "file_name",
                  "line_number": 10,
                  "col_offset": 62,
                  "type": "str"
                },
                {
                  "name": "docstring",
                  "line_number": 11,
                  "col_offset": 18,
                  "type": "str"
                },
                {
                  "name": "header",
                  "line_number": 11,
                  "col_offset": 41,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def gen_notebook(cells: List[Tuple[str, str]], tmp_dir: str, file_name: str,\n                 docstring: str = None, header: str = None):\n    nb = nbf.v4.new_notebook()\n    if header:\n        nb['cells'].append(nbf.v4.new_markdown_cell(header))\n    if docstring:\n        nb['cells'].append(nbf.v4.new_code_cell(docstring))\n    for type, cell_content in cells:\n        if type == 'code':\n            nb_cell = to_notebook_code_cell(cell_content)\n        else:\n            nb_cell = to_notebook_comment_cell(cell_content)\n        nb['cells'].append(nb_cell)\n    notebook_path = join(tmp_dir, file_name)\n    nbf.write(nb, notebook_path)\n    return notebook_path",
              "signature": "gen_notebook(cells: List[Tuple[str, str]], tmp_dir: str, file_name: str, docstring: str, header: str)",
              "full_signature": "gen_notebook(cells: List[Tuple[str, str]], tmp_dir: str, file_name: str, docstring: str, header: str)",
              "annotations": ""
            },
            {
              "name": "to_notebook_code_cell",
              "line_number": 28,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "cell_content",
                  "line_number": 28,
                  "col_offset": 27,
                  "type": "str"
                }
              ],
              "return_type": "nbf.NotebookNode",
              "body": "def to_notebook_code_cell(cell_content: str) -> nbf.NotebookNode:\n    return nbf.v4.new_code_cell(cell_content)",
              "signature": "to_notebook_code_cell(cell_content: str) -> nbf.NotebookNode",
              "full_signature": "to_notebook_code_cell(cell_content: str) -> nbf.NotebookNode",
              "annotations": ""
            },
            {
              "name": "to_notebook_comment_cell",
              "line_number": 32,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "cell_content",
                  "line_number": 32,
                  "col_offset": 30,
                  "type": "str"
                }
              ],
              "return_type": "nbf.NotebookNode",
              "body": "def to_notebook_comment_cell(cell_content: str) -> nbf.NotebookNode:\n    return nbf.v4.new_markdown_cell(cell_content)",
              "signature": "to_notebook_comment_cell(cell_content: str) -> nbf.NotebookNode",
              "full_signature": "to_notebook_comment_cell(cell_content: str) -> nbf.NotebookNode",
              "annotations": ""
            },
            {
              "name": "write_conf",
              "line_number": 36,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "work_dir",
                  "line_number": 36,
                  "col_offset": 16,
                  "type": "str"
                },
                {
                  "name": "conf_path",
                  "line_number": 36,
                  "col_offset": 31,
                  "type": "str"
                },
                {
                  "name": "ignore_keys",
                  "line_number": 36,
                  "col_offset": 47,
                  "type": "List[str]"
                },
                {
                  "name": "script_dir",
                  "line_number": 37,
                  "col_offset": 16,
                  "type": "str"
                },
                {
                  "name": "dvc_cmd_dir",
                  "line_number": 37,
                  "col_offset": 40,
                  "type": "str"
                },
                {
                  "name": "dvc_py_cmd_path",
                  "line_number": 38,
                  "col_offset": 16,
                  "type": "str"
                },
                {
                  "name": "dvc_py_cmd_name",
                  "line_number": 38,
                  "col_offset": 45,
                  "type": "str"
                },
                {
                  "name": "dvc_meta_file_name",
                  "line_number": 39,
                  "col_offset": 16,
                  "type": "str"
                },
                {
                  "name": "docstring_conf",
                  "line_number": 39,
                  "col_offset": 48,
                  "type": "str"
                }
              ],
              "return_type": "dict",
              "body": "def write_conf(work_dir: str, conf_path: str, ignore_keys: List[str] = None,\n               script_dir: str = None, dvc_cmd_dir: str = None,\n               dvc_py_cmd_path: str = None, dvc_py_cmd_name: str = None,\n               dvc_meta_file_name: str = None, docstring_conf: str = None) -> dict:\n    ignore_keys = ignore_keys or []\n    script_dir = script_dir or join('script')\n    dvc_cmd_dir = dvc_cmd_dir or join('cmd', 'dvc')\n    makedirs(join(work_dir, script_dir), exist_ok=True)\n    makedirs(join(work_dir, dvc_cmd_dir), exist_ok=True)\n    conf_data = {\n        'path': {\n            'python_script_root_dir': script_dir,\n            'dvc_cmd_root_dir': dvc_cmd_dir\n        },\n        'ignore_keys': ignore_keys,\n    }\n    if dvc_py_cmd_name:\n        conf_data['dvc_var_python_cmd_name'] = dvc_py_cmd_name\n    if dvc_py_cmd_path:\n        conf_data['dvc_var_python_cmd_path'] = dvc_py_cmd_path\n    if dvc_meta_file_name:\n        conf_data['dvc_var_meta_filename'] = dvc_meta_file_name\n    if docstring_conf:\n        conf_data['docstring_conf'] = docstring_conf\n    with open(conf_path, 'w') as fd:\n        json.dump(conf_data, fd)\n    return conf_data",
              "signature": "write_conf(work_dir: str, conf_path: str, ignore_keys: List[str], script_dir: str, dvc_cmd_dir: str, dvc_py_cmd_path: str, dvc_py_cmd_name: str, dvc_meta_file_name: str, docstring_conf: str) -> dict",
              "full_signature": "write_conf(work_dir: str, conf_path: str, ignore_keys: List[str], script_dir: str, dvc_cmd_dir: str, dvc_py_cmd_path: str, dvc_py_cmd_name: str, dvc_meta_file_name: str, docstring_conf: str) -> dict",
              "annotations": ""
            },
            {
              "name": "write_min_script",
              "line_number": 65,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "script_path",
                  "line_number": 65,
                  "col_offset": 22,
                  "type": "str"
                },
                {
                  "name": "docstring",
                  "line_number": 65,
                  "col_offset": 40,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def write_min_script(script_path: str, docstring: str = None):\n    docstring = docstring or '\"\"\" A description \"\"\"'\n    python_script = 'def my_funct():\\n' \\\n                    f'\\t{docstring}\\n' \\\n                    '\\tpass\\n'\n    with open(script_path, 'w') as fd:\n        fd.write(python_script)",
              "signature": "write_min_script(script_path: str, docstring: str)",
              "full_signature": "write_min_script(script_path: str, docstring: str)",
              "annotations": ""
            },
            {
              "name": "write_dvc_file",
              "line_number": 74,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "path",
                  "line_number": 74,
                  "col_offset": 20,
                  "type": "str"
                },
                {
                  "name": "cmd",
                  "line_number": 74,
                  "col_offset": 31,
                  "type": "str"
                },
                {
                  "name": "deps",
                  "line_number": 74,
                  "col_offset": 41,
                  "type": "List[str]"
                },
                {
                  "name": "outs",
                  "line_number": 74,
                  "col_offset": 58,
                  "type": "List[str]"
                }
              ],
              "return_type": null,
              "body": "def write_dvc_file(path: str, cmd: str, deps: List[str], outs: List[str]):\n    data = {'cmd': cmd,\n            'deps': [{'path': dep} for dep in deps],\n            'outs': [{'path': out} for out in outs]}\n    with open(path, 'w') as fd:\n        yaml.dump(data, fd)",
              "signature": "write_dvc_file(path: str, cmd: str, deps: List[str], outs: List[str])",
              "full_signature": "write_dvc_file(path: str, cmd: str, deps: List[str], outs: List[str])",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "test_cmd_arguments",
          "file_path": "tests/functional/ipynb_to_dvc/test_cmd_arguments.py",
          "functions": [
            {
              "name": "write_test_conf",
              "line_number": 29,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "work_dir",
                  "line_number": 29,
                  "col_offset": 21,
                  "type": "str"
                },
                {
                  "name": "conf_path",
                  "line_number": 29,
                  "col_offset": 36,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def write_test_conf(work_dir: str, conf_path: str = None):\n    dvc_dir = join(work_dir, 'dvc')\n    script_dir = join(work_dir, 'scritps')\n    conf_path = conf_path if conf_path else join(work_dir, DEFAULT_CONF_FILENAME)\n    write_conf(work_dir=work_dir, conf_path=conf_path,\n               script_dir=script_dir, dvc_cmd_dir=dvc_dir)\n    return script_dir, dvc_dir",
              "signature": "write_test_conf(work_dir: str, conf_path: str)",
              "full_signature": "write_test_conf(work_dir: str, conf_path: str)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "test_generated_content",
          "file_path": "tests/functional/ipynb_to_python/test_generated_content.py",
          "functions": [
            {
              "name": "is_in",
              "line_number": 11,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "expected",
                  "line_number": 11,
                  "col_offset": 11,
                  "type": "str"
                },
                {
                  "name": "file_content",
                  "line_number": 11,
                  "col_offset": 26,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def is_in(expected: str, file_content: str):\n    sanitized_expected = expected.replace('\\n', '').replace(' ', '')\n    sanitized_file_content = file_content.replace('\\n', '').replace(' ', '')\n\n    return sanitized_expected in sanitized_file_content",
              "signature": "is_in(expected: str, file_content: str)",
              "full_signature": "is_in(expected: str, file_content: str)",
              "annotations": ""
            },
            {
              "name": "generate_test_notebook",
              "line_number": 22,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "work_dir",
                  "line_number": 22,
                  "col_offset": 28,
                  "type": "str"
                },
                {
                  "name": "notebook_name",
                  "line_number": 22,
                  "col_offset": 43,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def generate_test_notebook(work_dir: str, notebook_name: str):\n    docstring = '\"\"\"\\n' \\\n                ':param str subset: The kind of subset to generate.\\n' \\\n                ':param int rate:\\n' \\\n                ':dvc-out output_file: {{ conf.output_file }}\\n' \\\n                '\"\"\"\\n'\n    docstring_cell = ('code', '#Parameters\\n{}subset = \"train\"\\n'.format(docstring))\n    code_cells = [\n        ('code',\n         'import numpy as np\\n'\n         'import pandas as pd\\n'\n         'from sklearn.datasets import fetch_20newsgroups\\n'),\n        ('code',\n         'newsgroups_train = fetch_20newsgroups(subset=subset,\\n'\n         '            remove=(\"headers\", \"footers\", \"quotes\"))'),\n        ('code', 'df_train.to_csv(\"data_train.csv\", index=None)')\n    ]\n    comment_cell = ('markdown', 'This is a comment cell')\n    no_effect_cells = [('code', '# Ignore\\n# No effect'\n                                'df_train = pd.DataFrame(newsgroups_train.data, columns=[\"data\"])'),\n                       ('code', '# No effect\\ndf_train')]\n    trailing_comment = ('markdown', 'This is a trailing comment cell')\n    traling_no_effect = ('code', '# No effect\\ntrailing = 2')\n\n    cells = [\n        docstring_cell,\n        code_cells[0],\n        code_cells[1],\n        comment_cell,\n        no_effect_cells[0],\n        no_effect_cells[1],\n\n        code_cells[2],\n        traling_no_effect,\n        trailing_comment\n    ]\n\n    notebook_path = gen_notebook(cells, work_dir, notebook_name)\n    dropped_cells = DroppedCells(no_effect_cells, [trailing_comment, traling_no_effect], docstring_cell)\n    kept_cells = KeptCells(code_cells, [comment_cell])\n    return kept_cells, dropped_cells, docstring, notebook_path",
              "signature": "generate_test_notebook(work_dir: str, notebook_name: str)",
              "full_signature": "generate_test_notebook(work_dir: str, notebook_name: str)",
              "annotations": ""
            },
            {
              "name": "check_content",
              "line_number": 65,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "docstring",
                  "line_number": 65,
                  "col_offset": 19,
                  "type": "str"
                },
                {
                  "name": "kept_cells",
                  "line_number": 65,
                  "col_offset": 35,
                  "type": "KeptCells"
                },
                {
                  "name": "dropped_cells",
                  "line_number": 65,
                  "col_offset": 58,
                  "type": "DroppedCells"
                },
                {
                  "name": "file_content",
                  "line_number": 65,
                  "col_offset": 87,
                  "type": null
                }
              ],
              "return_type": null,
              "body": "def check_content(docstring: str, kept_cells: KeptCells, dropped_cells: DroppedCells, file_content):\n    assert is_in(docstring, file_content), 'Docstring not found in generated script'\n\n    for _, cell in kept_cells.code:\n        assert is_in(cell, file_content), f'Code cell {cell} not found in generated script'\n    for _, cell in kept_cells.comment:\n        assert is_in(cell, file_content), f'Comment cell {cell} not found in generated script'\n\n    for _, cell in dropped_cells.no_effect:\n        assert not is_in(cell, file_content), f'No effect cell {cell} must be dropped'\n    for _, cell in dropped_cells.trailing:\n        assert not is_in(cell, file_content), f'Trailing cell {cell} must be dropped'\n    assert not is_in(dropped_cells.docstring_cell[1], file_content), f'Docstring cell {cell} must be dropped'",
              "signature": "check_content(docstring: str, kept_cells: KeptCells, dropped_cells: DroppedCells, file_content)",
              "full_signature": "check_content(docstring: str, kept_cells: KeptCells, dropped_cells: DroppedCells, file_content)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "test_conf",
          "file_path": "tests/functional/ipynb_to_python/test_conf.py",
          "functions": [
            {
              "name": "setup_with_conf",
              "line_number": 9,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "work_dir",
                  "line_number": 9,
                  "col_offset": 21,
                  "type": "str"
                },
                {
                  "name": "conf_path",
                  "line_number": 9,
                  "col_offset": 36,
                  "type": "str"
                }
              ],
              "return_type": "Tuple[str, str]",
              "body": "def setup_with_conf(work_dir: str, conf_path: str) -> Tuple[str, str]:\n    write_conf(work_dir=work_dir, conf_path=conf_path, script_dir='./test_scripts')\n    nb_path = gen_notebook([('markdown', '# test')], work_dir, 'nb_test.ipynb')\n    return conf_path, nb_path",
              "signature": "setup_with_conf(work_dir: str, conf_path: str) -> Tuple[str, str]",
              "full_signature": "setup_with_conf(work_dir: str, conf_path: str) -> Tuple[str, str]",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "test_conf",
          "file_path": "tests/functional/gen_dvc/test_conf.py",
          "functions": [
            {
              "name": "write_docstring_conf",
              "line_number": 11,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "path",
                  "line_number": 11,
                  "col_offset": 26,
                  "type": "str"
                },
                {
                  "name": "output_file",
                  "line_number": 11,
                  "col_offset": 37,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def write_docstring_conf(path: str, output_file: str):\n    with open(path, 'w') as fd:\n        yaml.dump({'out_file': output_file}, fd)",
              "signature": "write_docstring_conf(path: str, output_file: str)",
              "full_signature": "write_docstring_conf(path: str, output_file: str)",
              "annotations": ""
            },
            {
              "name": "setup_with_conf",
              "line_number": 16,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "work_dir",
                  "line_number": 16,
                  "col_offset": 21,
                  "type": "str"
                },
                {
                  "name": "conf_path",
                  "line_number": 16,
                  "col_offset": 36,
                  "type": "str"
                },
                {
                  "name": "docstring_conf_path",
                  "line_number": 16,
                  "col_offset": 59,
                  "type": "str"
                }
              ],
              "return_type": "Tuple[str, str]",
              "body": "def setup_with_conf(work_dir: str, conf_path: str = None, docstring_conf_path: str = None) -> Tuple[str, str]:\n    write_conf(work_dir=work_dir, conf_path=conf_path, ignore_keys=['# Ignore'],\n               dvc_cmd_dir='./dvc_cmd', docstring_conf=docstring_conf_path)\n    script_path = join(work_dir, 'script_path.py')\n    docstring = '\"\"\"\\n:param out:\\n:dvc-out out: {{ conf.out_file }}\\n\"\"\"' if docstring_conf_path else None\n    write_min_script(script_path, docstring)\n    return conf_path, script_path",
              "signature": "setup_with_conf(work_dir: str, conf_path: str, docstring_conf_path: str) -> Tuple[str, str]",
              "full_signature": "setup_with_conf(work_dir: str, conf_path: str, docstring_conf_path: str) -> Tuple[str, str]",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "test_content_consistency",
          "file_path": "tests/functional/check_all_script_consistency/test_content_consistency.py",
          "functions": [
            {
              "name": "write_script",
              "line_number": 29,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "path",
                  "line_number": 29,
                  "col_offset": 18,
                  "type": "str"
                },
                {
                  "name": "content",
                  "line_number": 29,
                  "col_offset": 29,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def write_script(path: str, content: str):\n    name = basename(path).replace('.py', '')\n    script_content = f'''\n#!/usr/bin/env python3\nimport argparse\ndef {name}():\n    {content}\n    print(\"end\")\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Command for script {name}')\n    args = parser.parse_args()\n    {name}()\n'''\n    with open(path, 'w') as fd:\n        fd.write(script_content)",
              "signature": "write_script(path: str, content: str)",
              "full_signature": "write_script(path: str, content: str)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "write_name",
          "file_path": "tests/large/gen_dvc/data/write_name.py",
          "functions": [
            {
              "name": "mlvtools_write_hello_in_file",
              "line_number": 6,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "input_file",
                  "line_number": 6,
                  "col_offset": 34,
                  "type": "str"
                },
                {
                  "name": "output_file",
                  "line_number": 6,
                  "col_offset": 51,
                  "type": "str"
                },
                {
                  "name": "name",
                  "line_number": 6,
                  "col_offset": 69,
                  "type": "str"
                }
              ],
              "return_type": null,
              "body": "def mlvtools_write_hello_in_file(input_file: str, output_file: str, name: str):\n    \"\"\"\n    :param str input_file: path to the input file\n    :param str output_file: path to the output file\n    :param str name: your name\n    :dvc-in input_file: {{conf.input_file}}\n    :dvc-out output_file: {{conf.output_file}}\n    :dvc-extra: --name {{conf.name}}\n    \"\"\"\n    marker_path = join(dirname(output_file), 'ran.once')\n    first_run = not exists(marker_path)\n    if first_run:\n        with open(marker_path, 'w') as fd:\n            fd.write(' ')\n\n    with open(output_file, 'w') as fd:\n        suffix = 'First run' if first_run else 'Not the first run'\n        fd.write(f'Hello {name}! {suffix}')",
              "signature": "mlvtools_write_hello_in_file(input_file: str, output_file: str, name: str)",
              "full_signature": "mlvtools_write_hello_in_file(input_file: str, output_file: str, name: str)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "script",
          "file_path": "tests/large/gen_dvc/data/script.py",
          "functions": [
            {
              "name": "mlvtools_notebook",
              "line_number": 6,
              "col_offset": 5,
              "parameters": [
                {
                  "name": "sanitized_data",
                  "line_number": 6,
                  "col_offset": 23,
                  "type": "str"
                },
                {
                  "name": "octal_data",
                  "line_number": 6,
                  "col_offset": 44,
                  "type": "str"
                },
                {
                  "name": "binary_data",
                  "line_number": 6,
                  "col_offset": 61,
                  "type": "str"
                },
                {
                  "name": "size_bin_data",
                  "line_number": 6,
                  "col_offset": 79,
                  "type": "int"
                }
              ],
              "return_type": null,
              "body": "def mlvtools_notebook(sanitized_data: str, octal_data: str, binary_data: str, size_bin_data: int):\n    \"\"\"\n    :param str sanitized_data: path to input sanitized data\n    :param str octal_data: path to octal data output file\n    :param str binary_data: path to binary data output file\n    :param int size_bin_data: number of bits in a binary value\n    :dvc-in sanitized_data: ./dummy/data/sanitized_data.txt\n    :dvc-out octal_data: ./dummy/data/octal_data.txt\n    :dvc-out binary_data: ./dummy/data/binary_data.txt\n    :dvc-extra: --size-bin-data 8\n    \"\"\"\n    with open(sanitized_data, 'r') as fd:\n        data = fd.read()\n\n    binaries = [d for d in data.split() if len(d.split('=')[1]) >= size_bin_data]\n\n    octals = [d for d in data.split() if len(d.split('=')[1]) == 3]\n\n    with open(octal_data, 'w') as fd:\n        fd.write(' '.join(octals))\n\n    with open(binary_data, 'w') as fd:\n        fd.write(' '.join(binaries))",
              "signature": "mlvtools_notebook(sanitized_data: str, octal_data: str, binary_data: str, size_bin_data: int)",
              "full_signature": "mlvtools_notebook(sanitized_data: str, octal_data: str, binary_data: str, size_bin_data: int)",
              "annotations": ""
            }
          ],
          "classes": []
        },
        {
          "name": "test_parse",
          "file_path": "tests/unit/diff/test_parse.py",
          "functions": [
            {
              "name": "script_base",
              "line_number": 47,
              "col_offset": 5,
              "parameters": [],
              "return_type": "str",
              "body": "def script_base() -> str:\n    python_content = \"\"\"\n# This is a comment\nimport os\nfrom Typing import List\n\ndef list_dir(dir_path:str) -> List[str]:\n    ''' A docstring '''\n    return os.listdir(dir_path)\n\nprint('Hello !!')\nprint(list_dir('/tmp'))\n\"\"\"\n    return python_content",
              "signature": "script_base() -> str",
              "full_signature": "script_base() -> str",
              "annotations": ""
            },
            {
              "name": "get_script_base_spaces_and_blank",
              "line_number": 63,
              "col_offset": 5,
              "parameters": [],
              "return_type": "str",
              "body": "def get_script_base_spaces_and_blank() -> str:\n    python_content = \"\"\"\n# This is a comment\nimport os\nfrom Typing import List\n\n\n\n\n\ndef list_dir(dir_path:str) -> List[str]:\n    ''' A docstring '''\n    return os.listdir(dir_path)\n\nprint('Hello !!')\nprint(list_dir('/tmp'))\n\"\"\"\n    return python_content",
              "signature": "get_script_base_spaces_and_blank() -> str",
              "full_signature": "get_script_base_spaces_and_blank() -> str",
              "annotations": ""
            },
            {
              "name": "get_script_diff_comment",
              "line_number": 83,
              "col_offset": 5,
              "parameters": [],
              "return_type": "str",
              "body": "def get_script_diff_comment() -> str:\n    python_content = \"\"\"\n# This is a different comment\nimport os\nfrom Typing import List\n\ndef list_dir(dir_path:str) -> List[str]:\n    ''' A docstring '''\n    # This a new comment\n    return os.listdir(dir_path)\n\nprint('Hello !!')\nprint(list_dir('/tmp'))\n\"\"\"\n    return python_content",
              "signature": "get_script_diff_comment() -> str",
              "full_signature": "get_script_diff_comment() -> str",
              "annotations": ""
            },
            {
              "name": "get_script_diff_docstring",
              "line_number": 100,
              "col_offset": 5,
              "parameters": [],
              "return_type": "str",
              "body": "def get_script_diff_docstring() -> str:\n    python_content = \"\"\"\n# This is a comment\nimport os\nfrom Typing import List\n\ndef list_dir(dir_path:str) -> List[str]:\n    ''' A different docstring '''\n    return os.listdir(dir_path)\n\nprint('Hello !!')\nprint(list_dir('/tmp'))\n\"\"\"\n    return python_content",
              "signature": "get_script_diff_docstring() -> str",
              "full_signature": "get_script_diff_docstring() -> str",
              "annotations": ""
            },
            {
              "name": "get_script_diff",
              "line_number": 116,
              "col_offset": 5,
              "parameters": [],
              "return_type": "str",
              "body": "def get_script_diff() -> str:\n    python_content = \"\"\"\n# This is a comment\nimport os\nfrom Typing import List\n\ndef list_dir(dir_path:str) -> List[str]:\n    ''' A docstring '''\n    return dir_path\n\nprint('Hello !!')\nprint(list_dir('/tmp'))\n\"\"\"\n    return python_content",
              "signature": "get_script_diff() -> str",
              "full_signature": "get_script_diff() -> str",
              "annotations": ""
            }
          ],
          "classes": []
        }
      ]
    }
  ]
}
